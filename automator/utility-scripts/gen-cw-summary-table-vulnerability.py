# -*- coding: utf-8 -*-

"""
    Copyright (C) 2019  Soheil Khodayari, IMDEA Software
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.
    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
    
"""

import sys
import os
import glob
import json
from datetime import datetime
#-----------------------------------------------------------------------#
#						Utils
#-----------------------------------------------------------------------#

def _get_current_date():
	timestamp = datetime.now().strftime('%d/%m/%Y at %H:%M:%S')
	return timestamp

def _divide_string_in_half(string):
	firstpart, secondpart = string[:len(string)/2], string[len(string)/2:]
	return firstpart, secondpart

def _divide_string_in_n_parts(string, n_parts):
	string=string+","
	size=len(string)/n_parts
	parts = []
	for i in range(0, len(string), size):
		part = string[i:i+size]
		part = part.replace("\"","")
		part = part.strip() #remove the start whitespace if any
		if part.endswith(","):
			part=part[:-1] #remove middle commas
		if part.startswith(","):
			part=part[1:]
		part = part.strip() #remove the start whitespace if any after removing commas
		if part!="" and part != ',' and part!="\"" and part!="'": 
			parts.append(part)
	# parts = [string[i:i+size].strip() for i in range(0, len(string), size)]
	return parts

def _all_same(items):
    return all(x == items[0] for x in items)


def _get_count_cw_report(directory):
	return len(glob.glob1(directory,"content-window-*.csv"))
#-----------------------------------------------------------------------#
#						   Main
#-----------------------------------------------------------------------#

def main():
	if len(sys.argv)!= 2:
		print "Script-Usage: you must provide siteId as argument, e.g.\n'python gen-summary-csv.py siteId'"
		return 0
	siteId = sys.argv[1]

	# siteId = 23
	timestamp = _get_current_date()

	#-------------------------------------------------------------------#
	#						Constants
	#-------------------------------------------------------------------#

	# directories
	AUTOMATOR_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))

	ROOT_DIR = os.path.join(AUTOMATOR_DIR, os.path.join("%s"%siteId, os.path.join("TestReports", "ContentWindow")))
	OUTPUT_DIR = ROOT_DIR

	# define inputs file names
	INPUTS_FILE_NAME="report-summary.out"

	BROWSER_INPUT_FILE="browser.json"

	# define output file name
	OUTPUT_FILE_NAME = "summary-table-vulnerability.out"
	OUTPUT_FILE_PATH_NAME = os.path.join(OUTPUT_DIR, OUTPUT_FILE_NAME)

	# define a TEMP file
	TEMP_FILE_NAME = "temp.out"
	TEMP_FILE_PATH_NAME= os.path.join(OUTPUT_DIR, TEMP_FILE_NAME)



	#-------------------------------------------------------------------#
	#					End Constants
	#-------------------------------------------------------------------#
	
	# Contains the contents of all INPUTS_FILE_NAME files as fp.read()
	summaryFileContents=[]

	# results dict ,  key=url, value=[[browser,browser_version, state,value], [[browser, browser_version, state,value],..]]
	resultsDict={}

	# { chrome: chrome-version, firefox: firefox-version,...}
	browserDict={}

	N_REPORTS = {"chrome":0, "firefox":0, "edge":0}
	LastBrowser = 'chrome'
	for subdir, dirs, files in os.walk(ROOT_DIR):
		browserSpecFile=os.path.join(subdir, BROWSER_INPUT_FILE)
		if not os.path.exists(browserSpecFile):
			continue #the main directory does not contain a browser json file
		with open(browserSpecFile, "r") as browserSpecFile:
			specData = json.load(browserSpecFile)
			browserDict[specData["BROWSER"].lower()]=specData["BROWSER_VERSION"].lower()
			LastBrowser = specData["BROWSER"].lower()

		N_REPORTS[LastBrowser] = _get_count_cw_report(subdir)

		reportPathName= os.path.join(subdir, INPUTS_FILE_NAME)
		if not os.path.exists(reportPathName):
			continue #the main directory does not contain a report
		with open(reportPathName, "r") as fp:
			content= fp.read()
			summaryFileContents.append(content)

	N_REPORTS_ALL = N_REPORTS['chrome'] # assume same number of data for all browsers
	# Number of different Browsers
	nBrowsers= len(summaryFileContents)
	# store all date  in temp file 
	with open(TEMP_FILE_PATH_NAME, "wb") as fp:
		for idx in range(nBrowsers):
			content = summaryFileContents[idx]
			fp.write(content)
			fp.write("\n\n")

	with open(TEMP_FILE_PATH_NAME, "r") as tempFP:
		tempFileLines = tempFP.readlines()
		distinctURLs=[]
		for i in range(len(tempFileLines)):
			line=tempFileLines[i]
			if line.startswith("URL:"):
				url=line.split(" ")[1].strip("\n")
				distinctURLs.append(url)
		distinctURLs=list(set(distinctURLs))

		for eachURL in distinctURLs:
			for i in range(len(tempFileLines)):
				line=tempFileLines[i]
				mValueStatesList = []
				if eachURL in line:
					try:
						for j in range(N_REPORTS_ALL): 
							mValueStatesList.append(tempFileLines[i+j+1]) # i.e. mValueStateList[j]= tempFileLines[i+j+1]

						if not _all_same(mValueStatesList):
							# not an stable result
							continue
						else:
							valueStates = mValueStatesList[0]
					except:
						print "NO-VALUE"
						continue
					# go back to top to find the header
					for j in range(i, 0, -1):
						lineHeading= tempFileLines[j]
						if not lineHeading.startswith("Test:"):
							continue
						lineStates=tempFileLines[j+1]
						if not lineStates.startswith("Header:"):
							print "FILE_FORMAT_WRONG"
							sys.exit()

						lineHeadingSeparator="\\"
						if "/" in lineHeading:
							lineHeadingSeparator="/"

						lineHeadingSplitted= lineHeading.split(lineHeadingSeparator)
						# browser (for writing to out)
						currentBrowser=lineHeadingSplitted[1]

						currentBrowserVersion=browserDict[currentBrowser.lower()]

						lineStates= lineStates[len("Header:"):].strip().strip("\n")
						lineStatesSeperator=","
						# list of states
						lineStatesSplitted= lineStates.split(lineStatesSeperator)
						stateCount= len(lineStatesSplitted)
						
						valueStates= valueStates.strip().strip("\n")
						valueStatesSeperator=", "
						valueStatesSpliteed= valueStates.split(valueStatesSeperator)
						# valueStatesSpliteed = [item.strip("\n").strip() for item in valueStatesSpliteed]
						if _all_same(valueStatesSpliteed):
							continue
						
						# create a dict of state:value
						states=[]
						for idx in range(0, len(lineStatesSplitted)):
							state=lineStatesSplitted[idx].strip()
							states.append(state)

						values=[]
						for idx in range(0, len(valueStatesSpliteed)):
							val=valueStatesSpliteed[idx].strip().strip(",").strip()
							values.append(val)
						
						stateValueDict={}
						for k in range(stateCount):
							stateValueDict[states[k]]=values[k]

						for stateAsKey in stateValueDict:
							vector=[currentBrowser, currentBrowserVersion, stateAsKey, stateValueDict[stateAsKey]]
							if eachURL in resultsDict:
								resultsDict[eachURL].append(vector)
							else:
								resultsDict[eachURL]=[vector]
						# the heading for this url is found
						break
							
	with open(OUTPUT_FILE_PATH_NAME, "wb") as outFileFp:
		outFileFp.write("======================================================================\n")
		outFileFp.write("[Subject]: Summary of Attacks For Content Window\n")
		outFileFp.write("[Generated]: %s\n"%timestamp )
		outFileFp.write("======================================================================\n\n\n")

		for eachKeyURL in resultsDict:
		    vectors=resultsDict[eachKeyURL]
		    WriteURLHeader=True
		    cats = {}
		    for vector in vectors:
		            currentCategory= vector[0]+ ", " + vector[1]
		            if currentCategory not in cats:
		                cats[currentCategory] = [vector]
		            else:
		                cats[currentCategory].append(vector)

		    SortedCats=[]
		    for eachCategory in cats:
		        SortedCats.append(eachCategory)
		    SortedCats.sort()
		    for eachCategory in SortedCats:
				vectors = cats[eachCategory]
				diff_cats = {}
				for vector in vectors:
				        currentFCCategory = vector[3]
				        if currentFCCategory not in diff_cats:
				                diff_cats[currentFCCategory]=[vector]
				        else:
				                diff_cats[currentFCCategory].append(vector)
				lenEventKeys = len(diff_cats.keys())
				#if lenEventKeys <=1:
				 #   continue # not needed here, check why ?!
				if WriteURLHeader:
				    WriteURLHeader=False
				    outFileFp.write("----------------------------------------------------------------------\n")
				    outFileFp.write("URL: %s\n"%eachKeyURL)
				    outFileFp.write("----------------------------------------------------------------------\n")
				outFileFp.write("- TestConfig: %s\n"%eachCategory)
				for frameCountCategory in diff_cats:
				        vectors=diff_cats[frameCountCategory]
				        outFileFp.write("\t\tFrameCount: {0}\t\tStates: ".format(frameCountCategory))
				        for idx in range(len(vectors)):
				                vector=vectors[idx]
				                stateLabel=vector[2].strip().strip(",").split("_")[0].strip()  # removes _cwLength from state name 
				                if idx == len(vectors)-1:
				                    outFileFp.write("%s\n"%stateLabel)
				                else:
				                    outFileFp.write("%s, "%stateLabel)
				outFileFp.write("\n")
if __name__ == "__main__":
	main()
